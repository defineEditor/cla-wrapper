<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>claWrapper.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnalysisVariableSet.html">AnalysisVariableSet</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#getFormattedItems">getFormattedItems</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#getNameList">getNameList</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#load">load</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="AnalysisVariableSet.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="CdiscLibrary.html">CdiscLibrary</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#checkConnection">checkConnection</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getFullProduct">getFullProduct</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getItemGroup">getItemGroup</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getItemGroups">getItemGroups</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductClasses">getProductClasses</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductClassList">getProductClassList</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductDetails">getProductDetails</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductGroupList">getProductGroupList</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductIdByAlias">getProductIdByAlias</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getProductList">getProductList</a></li><li data-type='method' style='display: none;'><a href="CdiscLibrary.html#getTrafficStats">getTrafficStats</a></li></ul></li><li><a href="CodeList.html">CodeList</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CodeList.html#getFormattedTerms">getFormattedTerms</a></li><li data-type='method' style='display: none;'><a href="CodeList.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="CodeList.html#load">load</a></li><li data-type='method' style='display: none;'><a href="CodeList.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="CodeList.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="CoreObject.html">CoreObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CoreObject.html#apiRequest">apiRequest</a></li></ul></li><li><a href="DataClass.html">DataClass</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DataClass.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="DataClass.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="DataClass.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="DataClass.html#load">load</a></li><li data-type='method' style='display: none;'><a href="DataClass.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="DataClass.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="Dataset.html">Dataset</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Dataset.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#getFormattedItems">getFormattedItems</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#getNameList">getNameList</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="Dataset.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="DataStructure.html">DataStructure</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DataStructure.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#getFormattedItems">getFormattedItems</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#load">load</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="DataStructure.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="Domain.html">Domain</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Domain.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="Domain.html#getFormattedItems">getFormattedItems</a></li><li data-type='method' style='display: none;'><a href="Domain.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="Domain.html#getNameList">getNameList</a></li><li data-type='method' style='display: none;'><a href="Domain.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="Domain.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Domain.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="Domain.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="Field.html">Field</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Field.html#parseResponse">parseResponse</a></li></ul></li><li><a href="Item.html">Item</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Item.html#getCodeList">getCodeList</a></li><li data-type='method' style='display: none;'><a href="Item.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="Item.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Item.html#parseItemResponse">parseItemResponse</a></li><li data-type='method' style='display: none;'><a href="Item.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="ItemGroup.html">ItemGroup</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ItemGroup.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#getFormattedItems">getFormattedItems</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#getNameList">getNameList</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#load">load</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="ItemGroup.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="Product.html">Product</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Product.html#findMatchingItems">findMatchingItems</a></li><li data-type='method' style='display: none;'><a href="Product.html#getCodeList">getCodeList</a></li><li data-type='method' style='display: none;'><a href="Product.html#getCodeListList">getCodeListList</a></li><li data-type='method' style='display: none;'><a href="Product.html#getCurrentItemGroups">getCurrentItemGroups</a></li><li data-type='method' style='display: none;'><a href="Product.html#getCurrentItems">getCurrentItems</a></li><li data-type='method' style='display: none;'><a href="Product.html#getItemGroup">getItemGroup</a></li><li data-type='method' style='display: none;'><a href="Product.html#getItemGroups">getItemGroups</a></li><li data-type='method' style='display: none;'><a href="Product.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="Product.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="Product.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Product.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="Product.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="ProductClass.html">ProductClass</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ProductClass.html#getItemGroup">getItemGroup</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getItemGroups">getItemGroups</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getProductGroupList">getProductGroupList</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getProductGroups">getProductGroups</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getProductIdByAlias">getProductIdByAlias</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getProductList">getProductList</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#load">load</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="ProductClass.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="ProductGroup.html">ProductGroup</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ProductGroup.html#getFullProduct">getFullProduct</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getItemGroup">getItemGroup</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getItemGroups">getItemGroups</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getProductIdByAlias">getProductIdByAlias</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getProductList">getProductList</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getProducts">getProducts</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#load">load</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="ProductGroup.html#toSimpleObject">toSimpleObject</a></li></ul></li><li><a href="Variable.html">Variable</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Variable.html#getCodeList">getCodeList</a></li><li data-type='method' style='display: none;'><a href="Variable.html#getRawResponse">getRawResponse</a></li><li data-type='method' style='display: none;'><a href="Variable.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Variable.html#parseItemResponse">parseItemResponse</a></li><li data-type='method' style='display: none;'><a href="Variable.html#parseResponse">parseResponse</a></li><li data-type='method' style='display: none;'><a href="Variable.html#toSimpleObject">toSimpleObject</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">claWrapper.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const apiRequest = require('./utils/apiRequest.js');
const convertToFormat = require('./utils/convertToFormat.js');
const matchItem = require('./utils/matchItem.js');

/**
 * MatchingOptions
 * @typedef {Object} MatchingOptions
 */
const defaultMatchingOptions = { mode: 'full', firstOnly: false };

/**
 * GetItemGroupOptions
 * @typedef {Object} GetItemGroupOptions
 * @property {String} format - Specifies the output format. Possible values: json, csv.
 */
const defaultGetItemGroupOptions = {};

/**
 * GetItemGroupsOptions
 * @typedef {Object} GetItemGroupsOptions
 * @property {Boolean} type - Specifies whether a short or full description of itemGroups is required. Possible values: short, long (default).
 * @property {String} format - Specifies the output format. Possible values: json, csv.
 */
const defaultGetItemGroupsOptions = { type: 'long' };

class CoreObject {
    /**
     * CDISC Library Core Object which contains API request functions and technical information
     */
    constructor ({ username, password, baseUrl } = {}) {
        this.username = username;
        this.password = password;
        if (baseUrl !== undefined) {
            this.baseUrl = baseUrl;
        } else {
            this.baseUrl = 'https://library.cdisc.org/api';
        }
        this.traffic = {
            incoming: 0,
            outgoing: 0
        };
    }

    /**
     * Make an API request
     *
     * @param {String} endpoint CDISC Library API endpoint
     * @param {Object} [headers] Optional additional headers for the request
     * @param {Boolean} [returnRaw] If true, a raw response is returned
     * @returns {Object} API response, if API request failed a blank object is returned
     */
    async apiRequest (endpoint, headers, returnRaw) {
        try {
            let response = await apiRequest({ username: this.username, password: this.password, url: this.baseUrl + endpoint, headers });
            // Count traffic
            if (response.connection) {
                this.traffic.incoming += response.connection.bytesRead;
                this.traffic.outgoing += response.connection.bytesWritten;
            }
            if (returnRaw) {
                return response;
            }
            if (response.statusCode === 200) {
                return JSON.parse(response.body);
            } else if (response.statusCode) {
                throw new Error('Request failed with code: ' + response.statusCode);
            } else {
                throw new Error('Request failed');
            }
        } catch (error) {
            if (returnRaw) {
                return { statusCode: -1, description: 'Request failed' };
            } else {
                throw new Error('Request failed');
            }
        }
    }
}

class BasicFunctions {
    /**
     * Functions used in multiple classes
     */

    /**
     * Get raw API response
     *
     * @param {String} [href] CDISC Library API endpoint. If not specified, href attribute of the object is used.
     * @returns {Object|undefined} Returns an JSON response if the request was successfull, otherwise returns undefined
     */
    async getRawResponse (href) {
        let link = href;
        if (href === undefined &amp;&amp; this.href !== undefined) {
            link = this.href;
        }
        if (this.coreObject &amp;&amp; link) {
            let response = await this.coreObject.apiRequest(link);
            if (typeof response === 'object') {
                return response;
            }
        }
    }

    /**
     * Load object from the CDISC Library
     *
     * @param {String} [href] CDISC Library API endpoint. If not specified, href attribute of the object is used.
     * @returns {boolean} Returns true in the object was successfully loaded, false otherwise
     */
    async load (href) {
        let response = await this.getRawResponse(href);
        if (response === undefined) {
            return false;
        } else {
            this.parseResponse(response);
            return true;
        }
    }

    /**
     * Convert class to simple object, without methods or technical elements
     *
     * @returns {Object} A new object
     */
    toSimpleObject () {
        let result = {};
        for (let prop in this) {
            // Remove all techical or inherited properties
            if (prop !== 'coreObject' &amp;&amp; this.hasOwnProperty(prop)) {
                result[prop] = this[prop];
            }
        }
        return result;
    }
}

class CdiscLibrary {
    /**
     * CDISC Library Main class
     */
    constructor ({ username, password, baseUrl, productClasses } = {}) {
        this.coreObject = new CoreObject({ username, password, baseUrl });
        this.productClasses = productClasses;
    }

    /**
     * Checks connection to the CDISC Library API
     *
     * @returns {Object} Returns response status code and description
     */
    async checkConnection () {
        let response;
        let result;
        try {
            response = await this.coreObject.apiRequest('/mdr/adam/adamig-1-1/datastructures/ADSL/variables/USUBJID', undefined, true);
            result = { statusCode: response.status };
        } catch (error) {
            response = { statusCode: -1, description: error.message };
        }
        if (response.statusCode === 200) {
            result.description = 'OK';
        } else if (response.statusCode === 401) {
            result.description = 'Authentication failed';
        } else if (response.statusCode === 404) {
            result.description = 'Resource not found';
        } else {
            result.description = 'Unknown';
        }
    }

    /**
     * Get an object with product classes
     *
     * @returns {Object} Product classes
     */
    async getProductClasses () {
        if (this.productClasses) {
            return this.productClasses;
        }
        let productClasses = {};
        let dataRaw = await this.coreObject.apiRequest('/mdr/products');
        if (dataRaw.hasOwnProperty('_links')) {
            Object.keys(dataRaw['_links']).forEach(pcId => {
                if (pcId !== 'self') {
                    let pcRaw = dataRaw['_links'][pcId];
                    productClasses[pcId] = new ProductClass({ coreObject: this.coreObject });
                    productClasses[pcId].parseResponse(pcId, pcRaw);
                }
            });
        }
        this.productClasses = productClasses;
        return productClasses;
    }

    /**
     * Get a list of product class names
     *
     * @returns {Array} Array of product class names
     */
    async getProductClassList () {
        if (this.productClasses) {
            return Object.keys(this.productClasses);
        } else {
            return Object.keys(await this.getProductClasses());
        }
    }

    /**
     * Get a list of product group names
     *
     * @returns {Array} Array of product groups
     */
    async getProductGroupList () {
        let result = [];
        let pcList = await this.getProductClassList();
        pcList.forEach(pcId => {
            result = result.concat(this.productClasses[pcId].getProductGroupList());
        });
        return result;
    }

    /**
     * Get a list of product names
     *
     * @param {String} [format] Specifies the output format. Possible values: json, csv.
     * @returns {Array} List of product names (IDs)
     */
    async getProductList (format = 'json') {
        let result = [];
        let pcList = await this.getProductClassList();
        pcList.forEach(pcId => {
            result = result.concat(this.productClasses[pcId].getProductList());
        });
        return convertToFormat(result, format);
    }

    /**
     * Get an object with a fully loaded product by name or alias
     *
     * @param alias {String} Product alias. Examples: sdtmig3-3, sdtm1.7, adamig11.
     * @param [loadBasicInfo] {Boolean} If true, will load only basic product details.
     * @returns {Object} Product
     */
    async getFullProduct (alias, loadBasicInfo) {
        let result;
        let pcs = await this.getProductClasses();
        // Get IDs
        let productFullId = await this.getProductIdByAlias(alias);
        if (productFullId) {
            let pgs = pcs[productFullId.productClassId].productGroups;
            let pg = pgs[productFullId.productGroupId];
            if (loadBasicInfo === true) {
                result = pg.products[productFullId.productId];
            } else {
                result = await pg.getFullProduct(productFullId.productId);
            }
        }
        return result;
    }

    /**
     * Get a dataset/dataStructure for a specific product
     *
     * @param name {String} Dataset name
     * @param productAlias {String} Product name alias. Examples: sdtmig3-3, sdtm1.7, adamig11.
     * @param options {GetItemGroupOptions}
     * @returns {Object} Dataset
     */
    async getItemGroup (name, productAlias, options) {
        let result;
        let defaultedOptions = { ...defaultGetItemGroupOptions, ...options };
        if (!this.productClasses) {
            await this.getProductClasses();
        }
        for (let productClass of Object.values(this.productClasses)) {
            result = await productClass.getItemGroup(name, productAlias, defaultedOptions);
            if (result !== undefined) {
                break;
            }
        }
        return result;
    }

    /**
     * Get an object with all datasets/domains/dataStructure
     * &lt;br> This method does not update the main object
     *
     * @param options {GetItemGroupsOptions}
     * @returns {Object} An object with datasets/domains/dataStructures
     * &lt;br> In case options.short is set to true, only name and label for each itemGroup are returned.
     * This approach does not load the full product and loads only the dataset information from the CDISC Library.
     */
    async getItemGroups (productAlias, options) {
        let defaultedOptions = { ...defaultGetItemGroupsOptions, ...options };
        let result;
        if (!this.productClasses) {
            await this.getProductClasses();
        }
        for (let productClass of Object.values(this.productClasses)) {
            result = await productClass.getItemGroups(productAlias, defaultedOptions);
            if (result !== undefined) {
                break;
            }
        }
        return result;
    }

    /**
     * Get an object with all datasets/domains/dataStructure/codelists
     *
     * @param options {Object} Detail options
     * &lt;br> type='short' {String} Short/extended list of product attributes. Possible values: short, long
     * &lt;br> format='object' {String} Output format. Possible values: json, csv
     * @returns {Object|String} Product list with details
     */
    async getProductDetails ({ type = 'short', format = 'json' } = {}) {
        let result = [];
        let productClasses = await this.getProductClasses();
        Object.values(productClasses).forEach(pc => {
            Object.values(pc.getProductGroups()).forEach(pg => {
                Object.values(pg.getProducts()).forEach(product => {
                    let productDetails = {};
                    if (type === 'short') {
                        productDetails.id = product.id;
                        productDetails.label = product.label;
                    } else if (type === 'long') {
                        for (let prop in product) {
                            // Remove all properties, which are objects or undefined
                            if (typeof product[prop] !== 'object' || product[prop] === undefined) {
                                productDetails[prop] = product[prop];
                            }
                        }
                    }
                    result.push(productDetails);
                });
            });
        });
        return convertToFormat(result, format);
    }

    /**
     * Get traffic used by the library in a human-readable format
     *
     * @param type='all' {String} Type of the traffic. Possible values: all, incoming, outgoing
     * @param format='char' {String} Output format. Possible values: char, num
     * @returns {String|Integer} Traffic used in a human-readable format or number of bytes
     */
    getTrafficStats (type = 'all', format = 'char') {
        const byteUnits = [' kB', ' MB', ' GB', ' TB', 'PB', 'EB', 'ZB', 'YB'];
        let traffic = 0;

        if (type === 'all') {
            traffic = this.coreObject.traffic.incoming + this.coreObject.traffic.outgoing;
        } else if (type === 'incoming') {
            traffic = this.coreObject.traffic.incoming;
        } else if (type === 'outgoing') {
            traffic = this.coreObject.traffic.outgoing;
        }

        if (format === 'num') {
            return traffic;
        } else {
            let i = -1;
            do {
                traffic = traffic / 1024;
                i++;
            } while (traffic > 1024);

            if (traffic === 0) {
                return '0 bytes';
            } else {
                return Math.max(traffic, 0.1).toFixed(1) + byteUnits[i];
            }
        }
    }

    /**
     * Get a product, product group, product class IDs by alias or substring, e.g. adamig11 agamig1-1 adamig1.1 will return adamig-1-1
     *
     * @param name {String} Product name alias
     * @returns {Object|undefined} Product, product group, product class IDs
     */
    async getProductIdByAlias (alias) {
        let result;
        let productClasses = this.productClasses;
        if (!productClasses) {
            productClasses = await this.getProductClasses();
        }
        Object.keys(productClasses).some(pcId => {
            let res = productClasses[pcId].getProductIdByAlias(alias);
            if (res) {
                result = { productClassId: pcId, ...res };
                return true;
            }
        });
        return result;
    }
}

class ProductClass extends BasicFunctions {
    /**
     * Product class
     * @extends BasicFunctions
     */
    constructor ({ name, productGroups, coreObject } = {}) {
        super();
        this.name = name;
        this.productGroups = productGroups;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to product classes
     *
     * @param name Product class name
     * @param pcRaw Raw CDISC API response
     */
    parseResponse (name, pcRaw) {
        this.name = name;
        let productGroups = {};
        if (pcRaw.hasOwnProperty('_links')) {
            Object.keys(pcRaw['_links']).forEach(pgId => {
                if (pgId !== 'self') {
                    let pgRaw = pcRaw['_links'][pgId];
                    productGroups[pgId] = new ProductGroup({ coreObject: this.coreObject });
                    productGroups[pgId].parseResponse(pgId, pgRaw);
                }
            });
        }
        this.productGroups = productGroups;
    }

    /**
     * Get an object with product groups
     *
     * @returns {Object} Product groups
     */
    getProductGroups () {
        if (this.productGroups) {
            return this.productGroups;
        } else {
            return {};
        }
    }

    /**
     * Get a list of product group names
     *
     * @returns {Array} Array of product groups
     */
    getProductGroupList () {
        if (this.productGroups) {
            return Object.keys(this.productGroups);
        } else {
            return [];
        }
    }

    /**
     * Get a list of product names
     *
     * @param {String} [format] Specifies the output format. Possible values: json, csv.
     * @returns {Array} List of product names (IDs)
     */
    getProductList (format = 'json') {
        let result = [];
        let pgList = this.getProductGroupList();
        pgList.forEach(pgId => {
            result = result.concat(this.getProductGroups()[pgId].getProductList());
        });
        return convertToFormat(result, format);
    }

    /**
     * Get a dataset/dataStructure for a specific product
     *
     * @param name {String} Dataset name
     * @param productAlias {String} Product name alias. Examples: sdtmig3-3, sdtm1.7, adamig11.
     * @param options {GetItemGroupOptions}
     * @returns {Object} Dataset
     */
    async getItemGroup (name, productAlias, options) {
        let result;
        let defaultedOptions = { ...defaultGetItemGroupOptions, ...options };
        for (let productGroup of Object.values(this.productGroups)) {
            result = await productGroup.getItemGroup(name, productAlias, defaultedOptions);
            if (result !== undefined) {
                break;
            }
        }
        return result;
    }

    /**
     * Get an object with all datasets/domains/dataStructure
     * &lt;br> This method does not update the main object
     *
     * @param options {GetItemGroupsOptions}
     * @returns {Object} An object with datasets/domains/dataStructures
     * &lt;br> In case options.short is set to true, only name and label for each itemGroup are returned.
     * This approach does not load the full product and loads only the dataset information from the CDISC Library.
     */
    async getItemGroups (productAlias, options) {
        let defaultedOptions = { ...defaultGetItemGroupsOptions, ...options };
        let result;
        for (let productGroup of Object.values(this.productGroups)) {
            result = await productGroup.getItemGroups(productAlias, defaultedOptions);
            if (result !== undefined) {
                break;
            }
        }
        return result;
    }

    /**
     * Get a product and product group IDs by alias or substring, e.g. adamig11 agamig1-1 adamig1.1 will return adamig-1-1
     *
     * @param name {String} Product name alias
     * @returns {Object|undefined} Product and product group IDs
     */
    getProductIdByAlias (alias) {
        let result;
        let productGroups = this.getProductGroups();
        Object.keys(productGroups).some(pgId => {
            let res = productGroups[pgId].getProductIdByAlias(alias);
            if (res !== undefined) {
                result = { productGroupId: pgId, ...res };
                return true;
            }
        });
        return result;
    }
}

class ProductGroup extends BasicFunctions {
    /**
     * Product Group class
     * @extends BasicFunctions
     */
    constructor ({ name, products = {}, coreObject } = {}) {
        super();
        this.name = name;
        this.products = products;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to product groups
     *
     * @param name {String} name
     * @param pgRaw {String} Raw CDISC API response
     * @returns {undefined}
     */
    parseResponse (name, pgRaw) {
        this.name = name;
        let products = {};
        pgRaw.forEach(gRaw => {
            let product = new Product({ ...gRaw, coreObject: this.coreObject });
            products[product.id] = product;
        });
        this.products = products;
    }

    /**
     * Get an object with products
     *
     * @returns {Object} Products
     */
    getProducts () {
        if (this.products) {
            return this.products;
        } else {
            return {};
        }
    }

    /**
     * Get a list of product names
     *
     * @param [format] {String} Specifies the output format. Possible values: json, csv.
     * @returns {Array} List of product names (IDs)
     */
    getProductList (format = 'json') {
        let result;
        if (this.products) {
            result = Object.keys(this.getProducts()).map(pId => this.products[pId].id);
        } else {
            result = [];
        }
        return convertToFormat(result, format);
    }

    /**
     * Get a product ID by alias or substring, e.g. adamig11 agamig1-1 adamig1.1 will return adamig-1-1
     *
     * @param name {String} Product name alias
     * @returns {Object|undefined} An object with product ID
     */
    getProductIdByAlias (alias) {
        let productId;
        if (this.products) {
            let productList = this.getProductList();
            // Try exact match first, then make it less strict
            productId = productList.find(id => (alias.toLowerCase() === id.toLowerCase()));
            // Remove - and .
            if (!productId) {
                productId = productList.find(id => (alias.toLowerCase().replace(/[-.]/g, '') === id.toLowerCase().replace(/[-.]/g, '')));
            }
            // Search by substring
            if (!productId) {
                productId = productList.find(id => (id.toLowerCase().replace(/[-.]/g, '')).includes(alias.toLowerCase().replace(/[-.]/g, '')));
            }
        }
        if (productId) {
            return { productId };
        }
    }

    /**
     * Get an object with a fully loaded product by name or alias
     *
     * @param alias {String} Product name alias
     * @param [loadBasicInfo] {Boolean} If true, will load only basic product details.
     * @returns {Object} Product
     */
    async getFullProduct (alias, loadBasicInfo) {
        let product;
        let idObj = this.getProductIdByAlias(alias);
        if (idObj !== undefined) {
            let id = idObj.productId;
            if (loadBasicInfo === true) {
                return this.products[id];
            } else {
                let productRaw = await this.coreObject.apiRequest(this.products[id].href);
                product = new Product({ ...this.products[id] });
                product.parseResponse(productRaw);
                product.fullyLoaded = true;
                this.products[id] = product;
            }
        }
        return product;
    }

    /**
     * Get a dataset/dataStructure for a specific product
     *
     * @param name {String} Dataset name
     * @param productAlias {String} Product name alias. Examples: sdtmig3-3, sdtm1.7, adamig11.
     * @param options {GetItemGroupOptions}
     * @returns {Object} Dataset
     */
    async getItemGroup (name, productAlias, options) {
        let defaultedOptions = { ...defaultGetItemGroupOptions, ...options };
        let idObj = this.getProductIdByAlias(productAlias);
        if (idObj) {
            return this.products[idObj.productId].getItemGroup(name, defaultedOptions);
        }
    }

    /**
     * Get an object with all datasets/domains/dataStructure
     * &lt;br> This method does not update the main object
     *
     * @param options {GetItemGroupsOptions}
     * @returns {Object} An object with datasets/domains/dataStructures
     * &lt;br> In case options.short is set to true, only name and label for each itemGroup are returned.
     * This approach does not load the full product and loads only the dataset information from the CDISC Library.
     */
    async getItemGroups (productAlias, options) {
        let defaultedOptions = { ...defaultGetItemGroupsOptions, ...options };
        let idObj = this.getProductIdByAlias(productAlias);
        if (idObj) {
            let id = idObj.productId;
            if (this.products[id].fullyLoaded !== true &amp;&amp; defaultedOptions.type !== 'short') {
                // If the product is not fully loaded
                await this.getFullProduct(id);
                return this.products[id].getItemGroups(defaultedOptions);
            } else {
                // When a short description is required of the product is fully loaded
                return this.products[id].getItemGroups(defaultedOptions);
            }
        }
    }
}

class Product extends BasicFunctions {
    /**
     * Product class
     * @extends BasicFunctions
     */
    constructor ({
        id, name, title, label, type, description, source, effectiveDate,
        registrationStatus, version, dataClasses, dataStructures, codelists, href,
        coreObject, model, datasetType, fullyLoaded = false,
    } = {}) {
        super();
        if (id) {
            this.id = id;
        } else if (href.startsWith('/mdr/ct/') || href.startsWith('/mdr/adam/')) {
            this.id = href.replace(/.*\/(.*)$/, '$1');
        } else {
            this.id = href.replace(/.*\/(.*)\/(.*)$/, '$1-$2');
        }
        this.name = name;
        this.label = title || label;
        this.type = type;
        this.description = description;
        this.source = source;
        this.effectiveDate = effectiveDate;
        this.registrationStatus = registrationStatus;
        this.href = href;
        this.coreObject = coreObject;
        this.dataStructures = dataStructures;
        this.dataClasses = dataClasses;
        this.codelists = codelists;
        // Non-standard attributes
        if (version) {
            this.version = version;
        } else if (/(\d+-?)+$/.test(href)) {
            this.version = href.replace(/.*?(\d[\d-]*$)/, '$1').replace('-', '.');
        }
        if (model) {
            this.model = model;
        } else {
            if (this.id.startsWith('adam')) {
                this.model = 'ADaM';
            } else if (this.id.startsWith('sdtm')) {
                this.model = 'SDTM';
            } else if (this.id.startsWith('send')) {
                this.model = 'SEND';
            } else if (this.id.startsWith('cdash')) {
                this.model = 'CDASH';
            }
        }
        if (datasetType) {
            this.datasetType = datasetType;
        } else if (this.type === 'Terminology') {
            this.datasetType = 'codelists';
        } else {
            if (this.model === 'ADaM') {
                this.datasetType = 'dataStructures';
            } else if (this.model === 'SDTM') {
                this.datasetType = 'datasets';
            } else if (this.model === 'SEND') {
                this.datasetType = 'datasets';
            } else if (this.model === 'CDASH') {
                this.datasetType = 'domains';
            }
        }

        if (this.model === 'ADaM' &amp;&amp; !this.dataStructures) {
            this.dataStructures = {};
        }
        if (['SDTM', 'SEND', 'CDASH'].includes(this.model) &amp;&amp; !this.dataClasses) {
            this.dataClasses = {};
        }
        this.fullyLoaded = fullyLoaded;
    }

    /**
     * Parse API response to product
     *
     * @param pRaw {Object} Raw CDISC API response
     */
    parseResponse (pRaw) {
        this.name = pRaw.name;
        this.description = pRaw.description;
        this.source = pRaw.source;
        this.effectiveDate = pRaw.effectiveDate;
        this.registrationStatus = pRaw.registrationStatus;
        this.version = pRaw.version;
        if (pRaw.hasOwnProperty('dataStructures')) {
            let dataStructures = {};
            pRaw.dataStructures.forEach(dataStructureRaw => {
                let href;
                if (dataStructureRaw['_links'] &amp;&amp; dataStructureRaw['_links'].self) {
                    href = dataStructureRaw['_links'].self.href;
                }
                let dataStructure = new DataStructure({
                    name: dataStructureRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                dataStructure.parseResponse(dataStructureRaw);
                dataStructures[dataStructure.id] = dataStructure;
            });
            this.dataStructures = dataStructures;
        }
        if (pRaw.hasOwnProperty('classes')) {
            let dataClasses = {};
            pRaw.classes.forEach(dataClassRaw => {
                let href;
                if (dataClassRaw['_links'] &amp;&amp; dataClassRaw['_links'].self) {
                    href = dataClassRaw['_links'].self.href;
                }
                let dataClass = new DataClass({
                    name: dataClassRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                dataClass.parseResponse(dataClassRaw);
                dataClasses[dataClass.id] = dataClass;
            });
            this.dataClasses = dataClasses;
        }
        if (pRaw.hasOwnProperty('codelists')) {
            let codelists = {};
            pRaw.classes.forEach(codeListRaw => {
                let href;
                if (codeListRaw['_links'] &amp;&amp; codeListRaw['_links'].self) {
                    href = codeListRaw['_links'].self.href;
                }
                let codeList = new CodeList({
                    name: codeListRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                codeList.parseResponse(codeListRaw);
                codelists[codeList.conceptId] = codeList;
            });
            this.codelists = codelists;
        }
    }

    /**
     * Get an object with all variables/fields for that product
     *
     * @returns {Object} An object with variables
     */
    async getItems () {
        if (this.fullyLoaded === true) {
            return this.getCurrentItems();
        } else {
            // Load the full product
            let productRaw = await this.coreObject.apiRequest(this.href);
            this.parseResponse(productRaw);
            this.fullyLoaded = true;
            return this.getCurrentItems();
        }
    }

    /**
     * Get an object with all variables/fields for that product which are currently loaded
     *
     * @returns {Object} An object with variables
     */
    getCurrentItems () {
        let sourceObject;
        let result = {};
        if (this.dataStructures) {
            sourceObject = this.dataStructures;
        } else if (this.dataClasses) {
            sourceObject = this.dataClasses;
        }
        if (sourceObject) {
            Object.values(sourceObject).forEach(obj => {
                result = { ...result, ...obj.getItems() };
            });
        }
        return result;
    }

    /**
     * Get an object with all datasets/domains/dataStructure
     * &lt;br> This method does not update the main object in case options.short is enabled
     *
     * @param options {GetItemGroupsOptions}
     * @returns {Object} An object with datasets/domains/dataStructures
     * &lt;br> In case options.short is set to true, only name and label for each itemGroup are returned.
     * This method does not load the full product and loads only the dataset information from the CDISC Library.
     */
    async getItemGroups (options) {
        let defaultedOptions = { ...defaultGetItemGroupsOptions, ...options };
        let result = {};
        if (defaultedOptions.type !== 'short') {
            if (this.fullyLoaded === true) {
                result = this.getCurrentItemGroups();
            } else {
                // Load the full product
                let productRaw = await this.coreObject.apiRequest(this.href);
                this.parseResponse(productRaw);
                this.fullyLoaded = true;
            }
        } else {
            if (this.fullyLoaded === true) {
                let itemGroups = this.getCurrentItemGroups();
                Object.values(itemGroups).forEach(itemGroup => {
                    result[itemGroup.name] = { name: itemGroup.name, label: itemGroup.label };
                });
            } else {
                let datasetsHref = `${this.href}/${this.datasetType.toLowerCase()}`;
                let itemGroupsRaw = await this.coreObject.apiRequest(datasetsHref);
                if (itemGroupsRaw &amp;&amp; itemGroupsRaw['_links'] &amp;&amp; itemGroupsRaw['_links'][this.datasetType]) {
                    itemGroupsRaw['_links'][this.datasetType].forEach(dsRaw => {
                        let name = dsRaw.href.replace(/.*\/(.*)$/, '$1');
                        result[name] = { name, label: dsRaw.title };
                    });
                }
            }
        }
        if (defaultedOptions.format === undefined) {
            return result;
        } else {
            if (defaultedOptions.type === 'short') {
                return convertToFormat(Object.values(result), defaultedOptions.format);
            } else {
                let formatted = [];
                Object.values(result).forEach(itemGroup => {
                    formatted = formatted.concat(itemGroup.getFormattedItems('json', true));
                });
                return convertToFormat(formatted, defaultedOptions.format);
            }
        }
    }

    /**
     * Get an object with all datasets/dataStructures for that product which are currently loaded
     *
     * @returns {Object} An object with datasets
     */
    getCurrentItemGroups () {
        let result = {};
        if (this.dataStructures) {
            return this.dataStructures;
        } else if (this.dataClasses) {
            Object.values(this.dataClasses).forEach(obj => {
                if (this.model === 'CDASH') {
                    result = { ...result, ...obj.domains };
                } else if (this.model === 'SDTM' || this.model === 'SEND') {
                    result = { ...result, ...obj.datasets };
                }
            });
        }
        return result;
    }

    /**
     * Get a dataset/dataStructure/domain
     * @param name {String} Dataset name
     * @param options {GetItemGroupOptions}
     *
     * @returns {Object} Dataset/DataStructure/Domain
     */
    async getItemGroup (name, options) {
        let result;
        let defaultedOptions = { ...defaultGetItemGroupsOptions, ...options };
        // Check if dataset is already present;
        let loadedDatasets = this.getCurrentItemGroups();
        let datasetId;
        Object.values(loadedDatasets).some(dataset => {
            if (dataset.name.toUpperCase() === name.toUpperCase()) {
                datasetId = dataset.id;
                return true;
            }
        });
        if (datasetId) {
            result = loadedDatasets[datasetId];
        } else {
            let href = `${this.href}/${this.datasetType.toLowerCase()}/${name.toUpperCase()}`;
            let dsRaw = await this.coreObject.apiRequest(href);
            if (dsRaw === null) {
                // Dataset not found
                return null;
            }
            if (this.datasetType.toLowerCase() === 'datastructures') {
                result = new DataStructure({
                    name: dsRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                result.parseResponse(dsRaw);
                this.dataStructures[result.id] = result;
            } else if (['datasets', 'domains'].includes(this.datasetType)) {
                if (this.datasetType === 'datasets') {
                    result = new Dataset({
                        name: dsRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    result.parseResponse(dsRaw);
                } else if (this.datasetType === 'domains') {
                    result = new Domain({
                        name: dsRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    result.parseResponse(dsRaw);
                }
                // Create a class to add this itemgroup to the main object
                if (dsRaw['_links'] &amp;&amp; dsRaw['_links'].parentClass) {
                    let dcRaw = dsRaw['_links'].parentClass;
                    let dataClass = new DataClass({
                        ...dcRaw,
                        coreObject: this.coreObject
                    });
                    dataClass.name = dataClass.id;
                    if (this.dataClasses &amp;&amp; this.dataClasses.hasOwnProperty(dataClass.id)) {
                        // If the dataClass is already present, add the dataset to it
                        this.dataClasses[dataClass.id][this.datasetType][result.id] = result;
                    } else {
                        // Otherwise create a new data class
                        dataClass[this.datasetType] = { [result.id]: result };
                        this.dataClasses[dataClass.id] = dataClass;
                    }
                }
            }
        }
        if (defaultedOptions.format === undefined) {
            return result;
        } else {
            return result.getFormattedItems(defaultedOptions.format);
        }
    }

    /**
     * Find all matching variables/fields. For example TRxxPGy matches TR01PG12.
     *
     * @param name {String} Variable/Field name
     * @param [options] {Object} Matching options. By default the following options are used: { mode: 'full', firstOnly: false }.
     * @param options.mode {String}  Match only full names, partial - match partial names
     * @param options.firstOnly {Boolean}  If true, returns only the first matching item, false - returns all matching items
     * @returns {Array} Array of matched items.
     */
    findMatchingItems (name, options) {
        // Default options
        let defaultedOptions = { ...defaultMatchingOptions, ...options };
        let result = [];
        let sourceObject;
        if (this.dataStructures) {
            sourceObject = this.dataStructures;
        } else if (this.dataClasses) {
            sourceObject = this.dataClasses;
        }
        if (sourceObject) {
            Object.values(sourceObject).some(obj => {
                let matches = obj.findMatchingItems(name, defaultedOptions);
                if (matches.length > 0) {
                    result = result.concat(matches);
                    if (defaultedOptions.firstOnly === true) {
                        return true;
                    }
                }
            });
        }
        return result;
    }

    /**
     * Get a list of codelists in terminology
     *
     * @param [options] {Object} Output options
     * @param options.short {Boolean} Keep only preferred term and ID in the result
     * @param options.format {String} Specifies the output format. Possible values: json, csv.
     * @returns {Array} Array of codelist IDs and titles.
     */
    async getCodeListList (options = {}) {
        let result = [];
        if (!this.codelists) {
            let codeListsHref = `${this.href}/codelists`;
            let clRaw = await this.coreObject.apiRequest(codeListsHref);
            if (clRaw.hasOwnProperty('_links') &amp;&amp; clRaw._links.hasOwnProperty('codelists')) {
                let codelists = {};
                clRaw._links.codelists.forEach(codeListRaw => {
                    let codeList = new CodeList({
                        href: codeListRaw.href,
                        preferredTerm: codeListRaw.title,
                        coreObject: this.coreObject
                    });
                    codelists[codeList.conceptId] = codeList;
                });
                this.codelists = codelists;
            }
        }
        Object.values(this.codelists).forEach(codeList => {
            if (options.short) {
                result.push({ conceptId: codeList.conceptId, preferredTerm: codeList.preferredTerm });
            } else {
                result.push({ conceptId: codeList.conceptId, preferredTerm: codeList.preferredTerm, href: codeList.href });
            }
        });
        return convertToFormat(result, options.format);
    }

    /**
     * Get a codelists
     *
     * @param {String} codeListId Concept ID of the codelist
     * @param {Object} [options] Output options
     * @param {String} options.format Specifies the output format. Possible values: json, csv.
     * @returns {Object} Codelist
     */
    async getCodeList (codeListId, options = {}) {
        let ct;
        if (this.codelists &amp;&amp; this.codelists[codeListId]) {
            ct = this.codelists[codeListId];
        }
        // If not found, try to loaded it. Even when found it is possible that the codelist is not fully loaded
        if ((ct === undefined &amp;&amp; !this.fullyLoaded) || (ct &amp;&amp; ct.terms.length &lt; 1)) {
            let href = this.href + '/codelists/' + codeListId;
            let codeList = new CodeList({
                href,
                coreObject: this.coreObject
            });
            let loaded = await codeList.load();
            if (loaded) {
                ct = codeList;
                if (!this.codelists) {
                    this.codelists = {};
                }
                this.codelists[ct.conceptId] = ct;
            }
        }

        if (ct) {
            if (options.format) {
                return ct.getFormattedTerms(options.format);
            } else {
                return ct;
            }
        }
    }
}

class DataStructure extends BasicFunctions {
    /**
     * Data Structure class
     * @extends BasicFunctions
     */
    constructor ({ name, label, description, className, analysisVariableSets, href, coreObject } = {}) {
        super();
        this.id = href.replace(/.*\/(.*)$/, '$1');
        this.name = name;
        this.label = label;
        this.description = description;
        this.className = className;
        this.analysisVariableSets = analysisVariableSets;
        this.href = href;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to data structure
     *
     * @param dsRaw Raw CDISC API response
     */
    parseResponse (dsRaw) {
        this.name = dsRaw.name;
        this.label = dsRaw.label || dsRaw.title;
        this.description = dsRaw.description;
        this.className = dsRaw.className;
        let analysisVariableSets = {};
        if (dsRaw.hasOwnProperty('analysisVariableSets')) {
            dsRaw.analysisVariableSets.forEach(analysisVariableSetRaw => {
                let href;
                let id;
                if (analysisVariableSetRaw['_links'] &amp;&amp; analysisVariableSetRaw['_links'].self) {
                    href = analysisVariableSetRaw['_links'].self.href;
                    id = href.replace(/.*\/(.*)$/, '$1');
                }
                if (!id) {
                    id = analysisVariableSetRaw.name;
                }
                analysisVariableSets[id] = new AnalysisVariableSet({
                    id,
                    name: analysisVariableSetRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                analysisVariableSets[id].parseResponse(analysisVariableSetRaw);
            });
        }
        this.analysisVariableSets = analysisVariableSets;
    }

    /**
     * Get an object with all variables/fields for that data structure
     *
     * @returns {Object} An object with variables
     */
    getItems () {
        let result = {};
        if (this.analysisVariableSets) {
            Object.values(this.analysisVariableSets).forEach(analysisVariableSet => {
                result = { ...result, ...analysisVariableSet.getItems() };
            });
        }
        return result;
    }

    /**
     * Find all matching variables/fields. For example TRxxPGy matches TR01PG12.
     *
     * @param name {String} Variable/Field name
     * @param options {Object} Matching options. By default the following options are used: { mode: 'full', firstOnly: false }.
     * &lt;br> mode {String} - match only full names, partial - match partial names
     * &lt;br> firstOnly {Boolean} true - returns only the first matching item, false - returns all matching items
     * @returns {Array} Array of matched items.
     */
    findMatchingItems (name, options) {
        // Default options
        let defaultedOptions = { ...defaultMatchingOptions, ...options };
        let result = [];
        if (this.analysisVariableSets) {
            Object.values(this.analysisVariableSets).some(analysisVariableSet => {
                let matches = analysisVariableSet.findMatchingItems(name, defaultedOptions);
                if (matches.length > 0) {
                    result = result.concat(matches);
                    if (defaultedOptions.firstOnly === true) {
                        return true;
                    }
                }
            });
        }
        return result;
    }

    /**
     * Get items in a specific format
     *
     * @param format {String} Specifies the output format. Possible values: json, csv, object.
     * @param addItemGroupId=false {Boolean} If set to true, itemGroup name is added to each records.
     * @returns {String|Array} String with formatted items or an array with item details.
     */
    getFormattedItems (format, addItemGroupId = false) {
        let result = [];
        if (this.analysisVariableSets) {
            Object.values(this.analysisVariableSets).forEach(analysisVariableSet => {
                result = result.concat(analysisVariableSet.getFormattedItems('json', addItemGroupId, { dataStructure: this.id }));
            });
            return convertToFormat(result, format);
        }
    }
}

class DataClass extends BasicFunctions {
    /**
     * Dataset Class class
     * @extends BasicFunctions
     */
    constructor ({ name, label, description, datasets, domains, classVariables, cdashModelFields, href, coreObject } = {}) {
        super();
        this.id = href.replace(/.*\/(.*)$/, '$1');
        this.name = name;
        this.label = label;
        this.description = description;
        this.datasets = datasets;
        this.domains = domains;
        this.classVariables = classVariables;
        this.cdashModelFields = cdashModelFields;
        this.href = href;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to data structure
     *
     * @param dcRaw Raw CDISC API response
     */
    parseResponse (dcRaw) {
        this.name = dcRaw.name;
        this.label = dcRaw.label;
        this.description = dcRaw.description;
        if (dcRaw.hasOwnProperty('datasets')) {
            let datasets = {};
            dcRaw.datasets.forEach(datasetRaw => {
                let href;
                let id;
                if (datasetRaw['_links'] &amp;&amp; datasetRaw['_links'].self) {
                    href = datasetRaw['_links'].self.href;
                    id = href.replace(/.*\/(.*)$/, '$1');
                }
                if (!id) {
                    id = datasetRaw.name;
                }
                datasets[id] = new Dataset({
                    id,
                    name: datasetRaw.name,
                    href,
                    coreObject: this.coreObject
                });
                datasets[id].parseResponse(datasetRaw);
            });
            this.datasets = datasets;
        }
        if (dcRaw.hasOwnProperty('classVariables')) {
            let classVariables = {};
            if (dcRaw.hasOwnProperty('classVariables')) {
                dcRaw.classVariables.forEach(variableRaw => {
                    let href;
                    if (variableRaw['_links'] &amp;&amp; variableRaw['_links'].self) {
                        href = variableRaw['_links'].self.href;
                    }
                    let variable = new Variable({
                        name: variableRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    classVariables[variable.id] = variable;
                    classVariables[variable.id].parseResponse(variableRaw);
                });
            }
            this.classVariables = classVariables;
        }
        if (dcRaw.hasOwnProperty('cdashModelFields')) {
            let cdashModelFields = {};
            if (dcRaw.hasOwnProperty('cdashModelFields')) {
                dcRaw.cdashModelFields.forEach(fieldRaw => {
                    let href;
                    if (fieldRaw['_links'] &amp;&amp; fieldRaw['_links'].self) {
                        href = fieldRaw['_links'].self.href;
                    }
                    let field = new Field({
                        name: fieldRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    cdashModelFields[field.id] = field;
                    cdashModelFields[field.id].parseResponse(fieldRaw);
                });
            }
            this.cdashModelFields = cdashModelFields;
        }
    }

    /**
     * Get an object with all variables/fields for that data structure
     *
     * @returns {Object} An object with variables
     */
    getItems () {
        let result = {};
        if (this.datasets) {
            Object.values(this.datasets).forEach(dataset => {
                result = { ...result, ...dataset.getItems() };
            });
        }
        if (this.classVariables) {
            Object.values(this.classVariables).forEach(variable => {
                result[variable.id] = variable;
            });
        }
        if (this.cdashModelFields) {
            Object.values(this.cdashModelFields).forEach(field => {
                result[field.id] = field;
            });
        }
        return result;
    }

    /**
     * Find all matching variables/fields. For example TRxxPGy matches TR01PG12.
     *
     * @param name {String} Variable/Field name
     * @param options {Object} Matching options. By default the following options are used: { mode: 'full', firstOnly: false }.
     * &lt;br> mode {String} - match only full names, partial - match partial names
     * &lt;br> firstOnly {Boolean} true - returns only the first matching item, false - returns all matching items
     * @returns {Array} Array of matched items.
     */
    findMatchingItems (name, options) {
        // Default options
        let defaultedOptions = { ...defaultMatchingOptions, ...options };
        let result = [];
        if (this.datasets) {
            Object.values(this.datasets).some(dataset => {
                let matches = dataset.findMatchingItems(name, defaultedOptions);
                if (matches.length > 0) {
                    result = result.concat(matches);
                    if (defaultedOptions.firstOnly === true) {
                        return true;
                    }
                }
            });
        }
        if (this.classVariables &amp;&amp; !(defaultedOptions.firstOnly &amp;&amp; result.length > 0)) {
            for (let variable of Object.values(this.classVariables)) {
                if (matchItem(name, variable, defaultedOptions.mode)) {
                    result.push(variable);
                    if (defaultedOptions.firstOnly === true) {
                        break;
                    }
                }
            }
        }
        if (this.cdashModelFields &amp;&amp; !(defaultedOptions.firstOnly &amp;&amp; result.length > 0)) {
            for (let field of Object.values(this.cdashModelFields)) {
                if (matchItem(name, field, defaultedOptions.mode)) {
                    result.push(field);
                    if (defaultedOptions.firstOnly === true) {
                        break;
                    }
                }
            }
        }
        return result;
    }
}

class ItemGroup extends BasicFunctions {
    /**
     * Item Set class: base for Dataset, DataStructure, Domain
     * @extends BasicFunctions
     */
    constructor ({ id, name, label, itemType, type, href, coreObject } = {}) {
        super();
        this.itemType = itemType;
        if (name) {
            this.name = name;
        } else {
            this.name = href.replace(/.*\/(.*)$/, '$1');
        }
        if (id) {
            this.id = id;
        } else {
            this.id = this.name;
        }
        this.label = label;
        this.href = href;
        this.type = type;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to variable set
     *
     * @param vsRaw Raw CDISC API response
     */
    parseResponse (itemRaw) {
        this.name = itemRaw.name;
        this.label = itemRaw.label;
        let items = {};
        if (itemRaw.hasOwnProperty(this.itemType)) {
            itemRaw[this.itemType].forEach(itemRaw => {
                let href;
                if (itemRaw['_links'] &amp;&amp; itemRaw['_links'].self) {
                    href = itemRaw['_links'].self.href;
                }
                let item;
                if (this.itemType === 'fields') {
                    item = new Field({
                        name: itemRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    item.parseResponse(itemRaw);
                    items[item.id] = item;
                } else if (['analysisVariables', 'datasetVariables'].includes(this.itemType)) {
                    item = new Variable({
                        name: itemRaw.name,
                        href,
                        coreObject: this.coreObject
                    });
                    item.parseResponse(itemRaw);
                    items[item.id] = item;
                }
            });
        }
        if (itemRaw.hasOwnProperty('_links')) {
            if (itemRaw._links.self &amp;&amp; itemRaw._links.self.type) {
                this.type = itemRaw._links.self.type;
            }
        }
        this[this.itemType] = items;
    }

    /**
     * Get an object with all variables/fields for that item set
     *
     * @returns {Object} An object with variables
     */
    getItems () {
        let result = {};
        if (this[this.itemType]) {
            Object.values(this[this.itemType]).forEach(item => {
                result[item.id] = item;
            });
        }
        return result;
    }

    /**
     * Get an array with the list of all items
     *
     * @returns {Array} An array with item names
     */
    getNameList () {
        let result = [];
        if (this[this.itemType]) {
            Object.values(this[this.itemType]).forEach(item => {
                result.push(item.name);
            });
        }
        return result;
    }

    /**
     * Find all matching variables/fields. For example TRxxPGy matches TR01PG12.
     *
     * @param name {String} Variable/field name
     * @param options {Object} Matching options. By default the following options are used: { mode: 'full', firstOnly: false }.
     * &lt;br> mode {String} - match only full names, partial - match partial names
     * &lt;br> firstOnly {Boolean} true - returns only the first matching item, false - returns all matching items
     * @returns {Array} Array of matched items.
     */
    findMatchingItems (name, options) {
        // Default options
        let defaultedOptions = { ...defaultMatchingOptions, ...options };
        let result = [];
        if (this[this.itemType]) {
            Object.values(this[this.itemType]).some(variable => {
                if (matchItem(name, variable, defaultedOptions.mode)) {
                    result.push(variable);
                    if (defaultedOptions.firstOnly === true) {
                        return true;
                    }
                }
            });
        }
        return result;
    }

    /**
     * Get items in a specific format
     *
     * @param format {String} Specifies the output format. Possible values: json, csv, object.
     * @param addItemGroupId=false {Boolean} If set to true, itemGroup name is added to each records.
     * @param additionalProps {Object} If provided, these properties will be added.
     * @returns {String|Array} String with formatted items or an array with item details.
     */
    getFormattedItems (format, addItemGroupId = false, additionalProps) {
        let items = this.getItems();
        let result = [];
        Object.values(items).forEach(item => {
            let updatedItem = {};
            if (addItemGroupId === true) {
                updatedItem = { itemGroup: this.id, ...item };
            } else {
                updatedItem = { ...item };
            }
            if (additionalProps) {
                updatedItem = { ...additionalProps, ...updatedItem };
            }
            if (item.valueList &amp;&amp; item.valueList.length > 0) {
                updatedItem.valueList = item.valueList.join(',');
            }
            // Remove all properties, which are Objects
            for (let prop in updatedItem) {
                if (typeof updatedItem[prop] === 'object') {
                    delete updatedItem[prop];
                }
            }
            result.push(updatedItem);
        });
        return convertToFormat(result, format);
    }
}

class Dataset extends ItemGroup {
    /**
     * Dataset class. Extends ItemGroup class. See {@link ItemGroup} for the list of available methods.
     * @extends ItemGroup
     */
    constructor ({ id, name, label, datasetVariables = {}, href, coreObject } = {}) {
        super({ id, name, label, itemType: 'datasetVariables', href, coreObject });
        this.datasetVariables = datasetVariables;
    }
}

class AnalysisVariableSet extends ItemGroup {
    /**
     * Analysis Variable Set class. Extends ItemGroup class. See {@link ItemGroup} for the list of available methods.
     * @extends ItemGroup
     */
    constructor ({ id, name, label, analysisVariables = {}, href, coreObject } = {}) {
        super({ id, name, label, itemType: 'analysisVariables', href, coreObject });
        this.analysisVariables = analysisVariables;
    }
}

class Domain extends ItemGroup {
    /**
     * Domain class. Extends ItemGroup class. See {@link ItemGroup} for the list of available methods.
     * @extends ItemGroup
     */
    constructor ({ id, name, label, fields = {}, href, coreObject } = {}) {
        super({ id, name, label, itemType: 'fields', href, coreObject });
        this.fields = fields;
    }
}

class CodeList extends BasicFunctions {
    /**
     * CodeList class
     * @extends BasicFunctions
     */
    constructor ({ conceptId, extensible, name, submissionValue, definition, preferredTerm, synonyms, terms = [], href, coreObject } = {}) {
        super();
        if (conceptId) {
            this.conceptId = conceptId;
        } else if (href) {
            this.conceptId = href.replace(/.*\/(.*)$/, '$1');
        }
        this.name = name;
        this.extensible = extensible;
        this.submissionValue = submissionValue;
        this.definition = definition;
        this.preferredTerm = preferredTerm;
        this.synonyms = synonyms;
        this.terms = terms;
        this.href = href;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to codelist
     *
     * @param clRaw Raw CDISC API response
     */
    parseResponse (clRaw) {
        this.conceptId = clRaw.conceptId;
        this.name = clRaw.name;
        if (clRaw.extensible === 'true') {
            this.extensible = true;
        } else if (clRaw.extensible === 'false') {
            this.extensible = false;
        }
        this.submissionValue = clRaw.submissionValue;
        this.definition = clRaw.definition;
        this.preferredTerm = clRaw.preferredTerm;
        this.synonyms = clRaw.synonyms;
        this.terms = clRaw.terms;
    }

    /**
     * Get codelist terms in a specific format
     *
     * @param format {String} Specifies the output format. Possible values: json, csv.
     * @returns {String} Formatted codeList terms.
     */
    getFormattedTerms (format = 'json') {
        return convertToFormat(this.terms, format);
    }
}

class Item extends BasicFunctions {
    /**
     * Item class
     * @extends BasicFunctions
     */
    constructor ({ id, ordinal, name, label, simpleDatatype, codelist, codelistHref, type, href, coreObject } = {}) {
        super();
        if (id) {
            this.id = id;
        } else {
            // Get datastructure/dataset/domain abbreviation
            if (/\/(?:datastructures|datasets|domains)\//.test(href)) {
                this.id = href.replace(/.*\/(?:datastructures|datasets|domains)\/(.*?)\/.*\/(.*)$/, '$1.$2');
            } else {
                this.id = href.replace(/.*\/(.*)$/, '$1');
            }
        }
        this.ordinal = ordinal;
        this.name = name;
        this.label = label;
        this.simpleDatatype = simpleDatatype;
        this.codelist = codelist;
        this.codelistHref = codelistHref;
        this.type = type;
        this.href = href;
        this.coreObject = coreObject;
    }

    /**
     * Parse API response to item
     *
     * @param itemRaw Raw CDISC API response
     */
    parseItemResponse (itemRaw) {
        this.ordinal = itemRaw.ordinal;
        this.name = itemRaw.name;
        this.label = itemRaw.label;
        this.simpleDatatype = itemRaw.simpleDatatype;
        if (itemRaw.hasOwnProperty('_links')) {
            if (itemRaw._links.codelist &amp;&amp; Array.isArray(itemRaw._links.codelist) &amp;&amp; itemRaw._links.codelist.length > 0 &amp;&amp; itemRaw._links.codelist[0].href) {
                this.codelistHref = itemRaw._links.codelist[0].href;
                this.codelist = itemRaw._links.codelist[0].href.replace(/.*\/(\S+)/, '$1');
            } else if (itemRaw._links.codelist &amp;&amp; itemRaw._links.codelist.href) {
                this.codelistHref = itemRaw._links.codelist.href;
                this.codelist = itemRaw._links.codelist.href.replace(/.*\/(\S+)/, '$1');
            }
            if (itemRaw._links.self &amp;&amp; itemRaw._links.self.type) {
                this.type = itemRaw._links.self.type;
            }
        }
    }

    /**
     * Get a Codelist object corresponding to the codelist used by the item
     *
     * @param ctVer {String} Version of the CT, for example 2015-06-26. If blank, the last (not necessarily the latest) version will be returned.
     * @returns {Object|undefined} Instance of the CodeList class if item has a codelist.
     */
    async getCodeList (ctVer) {
        if (this.codelistHref) {
            let rootCodeListRaw = await this.getRawResponse(this.codelistHref);
            if (rootCodeListRaw === undefined) {
                return;
            }
            if (rootCodeListRaw._links &amp;&amp; rootCodeListRaw._links.versions) {
                let href;
                if (ctVer) {
                    rootCodeListRaw._links.versions.some(version => {
                        if (version.href.includes(ctVer)) {
                            href = version.href;
                            return true;
                        }
                    });
                } else {
                    href = rootCodeListRaw._links.versions[rootCodeListRaw._links.versions.length - 1].href;
                }
                if (href) {
                    let codelist = new CodeList({ href, coreObject: this.coreObject });
                    await codelist.load();
                    return codelist;
                }
            }
        }
    }
}

class Variable extends Item {
    /**
     * Variable class
     * @extends Item
     */
    constructor ({ id, ordinal, name, label, description, core, simpleDatatype, role, roleDescription,
        valueList = [], codelist, codelistHref, describedValueDomain, href, coreObject
    } = {}) {
        super({ id, ordinal, name, label, simpleDatatype, codelist, codelistHref, href, coreObject });
        this.description = description;
        this.core = core;
        this.role = role;
        this.roleDescription = roleDescription;
        this.valueList = valueList;
        this.describedValueDomain = describedValueDomain;
    }

    /**
     * Parse API response to variable
     *
     * @param vRaw Raw CDISC API response
     */
    parseResponse (vRaw) {
        this.parseItemResponse(vRaw);
        this.description = vRaw.description;
        this.core = vRaw.core;
        this.role = vRaw.role;
        this.roleDescription = vRaw.roleDescription;
        this.valueList = vRaw.valueList;
        this.describedValueDomain = vRaw.describedValueDomain;
    }
}

class Field extends Item {
    /**
     * CDASH Field class
     */
    constructor ({ id, ordinal, name, label, definition, questionText, prompt, completionInstructions, implementationNotes,
        simpleDatatype, mappingInstructions, sdtmigDatasetMappingTargetsHref, codelist, codelistHref, href, coreObject } = {}
    ) {
        super({ id, ordinal, name, label, simpleDatatype, codelist, codelistHref, href, coreObject });
        this.definition = definition;
        this.questionText = questionText;
        this.prompt = prompt;
        this.completionInstructions = completionInstructions;
        this.implementationNotes = implementationNotes;
        this.mappingInstructions = mappingInstructions;
        this.sdtmigDatasetMappingTargetsHref = sdtmigDatasetMappingTargetsHref;
    }

    /**
     * Parse API response to variable
     *
     * @param fRaw Raw CDISC API response
     */
    parseResponse (fRaw) {
        this.parseItemResponse(fRaw);
        this.definition = fRaw.definition;
        this.questionText = fRaw.questionText;
        this.prompt = fRaw.prompt;
        this.completionInstructions = fRaw.completionInstructions;
        this.implementationNotes = fRaw.implementationNotes;
        this.mappingInstructions = fRaw.mappingInstructions;
        if (fRaw.hasOwnProperty('_links')) {
            if (fRaw._links.sdtmigDatasetMappingTargets &amp;&amp; fRaw._links.sdtmigDatasetMappingTargets.href) {
                this.sdtmigDatasetMappingTargetsHref = fRaw._links.sdtmigDatasetMappingTargets.href;
            }
        }
    }
}

module.exports = {
    CdiscLibrary,
    ProductClass,
    ProductGroup,
    Product,
    DataStructure,
    Dataset,
    Domain,
    DataClass,
    AnalysisVariableSet,
    Variable,
    Field,
    CodeList,
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
